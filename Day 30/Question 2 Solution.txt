package recursion;

import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.TreeSet;

public class MinimumCost {

	private static class Pair<K, V> {

		K key;
		V value;

		public Pair(K element0, V element1) {
			this.key = element0;
			this.value = element1;
		}

		@Override
		public String toString() {
			return key + " " + value;
		}
	}

	static int[] arr;
	static int N;
	static int x;
	static int result;

	public static void main(String[] args) {
		N = 1;
		x = 70;
		result = Integer.MAX_VALUE;
		arr = new int[N];
		arr[0] = 100;
//		arr[1] = 30;
//		arr[2] = 100;
//		arr[3] = 30;
//		arr[4] = 100;
//		arr[5] = 30;
		List<Deque<Pair<Integer, Integer>>> q = new ArrayList<>(N);
		TreeSet<Integer> t = new TreeSet<>();
		for (int ele : arr) {
			t.add(ele);
		}
		populateQueue(t, q, arr);
		calculateCostAtVariousValues(x, arr, q);
		System.out.println(result);
	}

	private static void calculateCostAtVariousValues(int x, int[] arr, List<Deque<Pair<Integer, Integer>>> q) {
		int maxStage = getHighestStageFromQueue(q);
		for (int i = maxStage; i >= 0; --i) {
			int value = x * i + sumUpValues(q);
			if (value < result)
				result = value;
			removeMaxStage(q, i);
		}
	}

	private static void removeMaxStage(List<Deque<Pair<Integer, Integer>>> q, int maxStage) {
		for (Deque<Pair<Integer, Integer>> list : q) {
			if (list.getFirst().key.equals(maxStage))
				list.pollFirst();
		}
	}

	private static int sumUpValues(List<Deque<Pair<Integer, Integer>>> q) {
		int sum = 0;
		for (Deque<Pair<Integer, Integer>> list : q) {
			sum += list.getFirst().value;
		}
		return sum;
	}

	private static int getHighestStageFromQueue(List<Deque<Pair<Integer, Integer>>> q) {
		int max = 0;
		for (Deque<Pair<Integer, Integer>> list : q) {
			if (list.getFirst().key > max)
				max = list.getFirst().key;
		}
		return max;
	}

	private static int incrementIndex(int index, int length) {
		return (index + 1) % length;
	}

	private static int getPreviousIndex(int index, int length) {
		if (index == 0)
			return length - 1;
		else
			return index - 1;
	}

	private static void populateQueue(TreeSet<Integer> t, List<Deque<Pair<Integer, Integer>>> q, int[] arr) {
		Iterator<Integer> iter = t.iterator();
		for (int i = 0; i < arr.length; ++i) {
			q.add(new LinkedList<>());
		}
		while (iter.hasNext()) {
			int ele = iter.next(), c = 0, index = -1;
			HashSet<Integer> covered = new HashSet<Integer>(arr.length);
			for (int i = 0; i < arr.length; ++i) {
				if (arr[i] == ele) {
					++c;
					index = i;
					q.get(i).addLast(new Pair<>(0, ele));
					covered.add(i);
				}
			}
			index = incrementIndex(index, arr.length);
			while (c < arr.length) {
				if (!covered.contains(index)) {
					Pair<Integer, Integer> p = q.get(getPreviousIndex(index, arr.length)).getLast();
					q.get(index).addLast(new Pair<>(p.key + 1, p.value));
					++c;
					covered.add(index);
				}
				index = incrementIndex(index, arr.length);
			}
		}
	}
}
